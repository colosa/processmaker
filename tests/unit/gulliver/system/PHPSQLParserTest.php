<?php
require_once PATH_TRUNK . 'gulliver' . PATH_SEP . "system" . PATH_SEP . "class.phpSqlParser.php";
 /**
 * Generated by PHPUnit_SkeletonGenerator on 2012-05-17 at 18:10:09.
 */
class PHPSQLParserTest extends PHPUnit_Framework_TestCase
{
    /**
     * @var PHPSQLParser
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
      //$this->object = new PHPSQLParser;
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
    }

    /**
     * @covers PHPSQLParser::parse
     * @todo   Implement testParse().
     */
    public function testParse()
    {
      $object = new PHPSQLParser();
      $value = array();

      //Testing with empty
      $sql = '';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      $this->assertEquals($object->parsed, $value);

      //Testing with Select , from
      $sql = 'SELECT * FROM USERS';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('SELECT', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['SELECT']);
      $this->assertArrayHasKey('expr_type', $object->parsed['SELECT'][0]);
      $this->assertEquals($object->parsed['SELECT'][0]['expr_type'], 'operator');
      $this->assertArrayHasKey('alias', $object->parsed['SELECT'][0]);
      $this->assertEquals($object->parsed['SELECT'][0]['alias'], '`*`');
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $this->assertArrayHasKey('table', $object->parsed['FROM'][0]);
      $this->assertEquals($object->parsed['FROM'][0]['table'], 'USERS');

      //Testing with Select, from, where
      $sql = 'SELECT USR_UID, USR_USERNAME, USR_PASSWORD, USR_FIRSTNAME, USR_LASTNAME, USR_EMAIL, USR_DUE_DATE, USR_CREATE_DATE, USR_UPDATE_DATE, USR_STATUS, USR_COUNTRY, USR_CITY, USR_LOCATION, USR_ADDRESS, USR_PHONE, USR_FAX, USR_CELLULAR, USR_ZIP_CODE, DEP_UID, USR_POSITION, USR_RESUME, USR_BIRTHDAY, USR_ROLE, USR_REPORTS_TO, USR_REPLACED_BY, USR_UX FROM USERS WHERE USR_UID = 00000000000000000000000000000001';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      $value = array('USR_UID','USR_USERNAME','USR_PASSWORD','USR_FIRSTNAME','USR_LASTNAME','USR_EMAIL','USR_DUE_DATE','USR_CREATE_DATE','USR_UPDATE_DATE','USR_STATUS','USR_COUNTRY','USR_CITY','USR_LOCATION','USR_ADDRESS','USR_PHONE','USR_FAX','USR_CELLULAR','USR_ZIP_CODE','DEP_UID','USR_POSITION','USR_RESUME','USR_BIRTHDAY','USR_ROLE','USR_REPORTS_TO','USR_REPLACED_BY','USR_UX');
      
      $this->assertArrayHasKey('SELECT', $object->parsed);
      foreach ($value as $key => $val) {
        $this->assertArrayHasKey('expr_type', $object->parsed['SELECT'][$key]);
        $this->assertEquals($object->parsed['SELECT'][$key]['expr_type'], 'colref');
        $this->assertArrayHasKey('alias', $object->parsed['SELECT'][$key]);
        $this->assertEquals($object->parsed['SELECT'][$key]['alias'], "`".$value[$key]."`");
      }
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $this->assertArrayHasKey('table', $object->parsed['FROM'][0]);
      $this->assertEquals($object->parsed['FROM'][0]['table'], 'USERS');
      
      $this->assertArrayHasKey('WHERE', $object->parsed);
      $index = 0;
      while ($index < 3) {
        $this->assertArrayHasKey($index, $object->parsed['WHERE']);
        $this->assertArrayHasKey('expr_type', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('base_expr', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('sub_tree', $object->parsed['WHERE'][$index]);
        switch ($index) {
          case '0':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], 'USR_UID');
            break;
          case '1':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'operator');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], '=');
            break;
          case '2':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'const');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], '00000000000000000000000000000001');
            break;
        }
        $index++;
      }

      //Testing with Select, from,left join, using
      $sql = 'SELECT USR_UID, USR_USERNAME, USR_PASSWORD, USR_FIRSTNAME, USR_LASTNAME, USR_EMAIL, USR_DUE_DATE, USR_CREATE_DATE, USR_UPDATE_DATE, USR_STATUS, USR_COUNTRY, USR_CITY, USR_LOCATION, USR_ADDRESS, USR_PHONE, USR_FAX, USR_CELLULAR, USR_ZIP_CODE, DEP_UID, USR_POSITION, USR_RESUME, USR_BIRTHDAY, USR_ROLE, USR_REPORTS_TO, USR_REPLACED_BY, USR_UX FROM USERS LEFT JOIN USERS_PROPERTIES USING (USR_UID)';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('SELECT', $object->parsed);
      foreach ($value as $key => $val) {
        $this->assertArrayHasKey('expr_type', $object->parsed['SELECT'][$key]);
        $this->assertEquals($object->parsed['SELECT'][$key]['expr_type'], 'colref');
        $this->assertArrayHasKey('alias', $object->parsed['SELECT'][$key]);
        $this->assertEquals($object->parsed['SELECT'][$key]['alias'], "`".$value[$key]."`");
      }
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['FROM']);
      $this->assertArrayHasKey('1', $object->parsed['FROM']);
      $this->assertArrayHasKey('table', $object->parsed['FROM'][0]);
      $this->assertArrayHasKey('table', $object->parsed['FROM'][1]);
      $this->assertEquals($object->parsed['FROM'][0]['table'], 'USERS');
      $this->assertEquals($object->parsed['FROM'][0]['join_type'], 'JOIN');
      $this->assertEquals($object->parsed['FROM'][1]['table'], 'USERS_PROPERTIES');
      $this->assertEquals($object->parsed['FROM'][1]['join_type'], 'LEFT ');
      $this->assertEquals($object->parsed['FROM'][1]['ref_type'], 'USING');
      $this->assertEquals($object->parsed['FROM'][1]['ref_clause'], 'USR_UID');

      //Testing with Select, Distinct, from, where , group, having, order
      $sql = 'SELECT DISTINCT  USR_UID, USR_USERNAME, USR_PASSWORD, USR_FIRSTNAME, USR_LASTNAME, USR_EMAIL, USR_DUE_DATE, USR_CREATE_DATE, USR_UPDATE_DATE, USR_STATUS, USR_COUNTRY, USR_CITY, USR_LOCATION, USR_ADDRESS, USR_PHONE, USR_FAX, USR_CELLULAR, USR_ZIP_CODE, DEP_UID, USR_POSITION, USR_RESUME, USR_BIRTHDAY, USR_ROLE, USR_REPORTS_TO, USR_REPLACED_BY, USR_UX FROM USERS WHERE USR_ROLE = PROCESSMAKER_OPERATOR  GROUP BY USR_STATUS  HAVING USR_STATUS = ACTIVE ORDER BY USR_CREATE_DATE DESC';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('OPTIONS', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['OPTIONS']);
      $this->assertEquals($object->parsed['OPTIONS'][0], 'DISTINCT');
      
      $this->assertArrayHasKey('SELECT', $object->parsed);
      foreach ($value as $key => $val) {
        $this->assertArrayHasKey('expr_type', $object->parsed['SELECT'][$key]);
        $this->assertEquals($object->parsed['SELECT'][$key]['expr_type'], 'colref');
        $this->assertArrayHasKey('alias', $object->parsed['SELECT'][$key]);
        $this->assertEquals($object->parsed['SELECT'][$key]['alias'], "`".$value[$key]."`");
        $this->assertArrayHasKey('sub_tree', $object->parsed['SELECT'][$key]);
        $this->assertEquals($object->parsed['SELECT'][$key]['sub_tree'], '');
      }
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $this->assertArrayHasKey('table', $object->parsed['FROM'][0]);
      $this->assertEquals($object->parsed['FROM'][0]['table'], 'USERS');
      
      $this->assertArrayHasKey('WHERE', $object->parsed);
      $index = 0;
      while ($index < 3) {
        $this->assertArrayHasKey($index, $object->parsed['WHERE']);
        $this->assertArrayHasKey('expr_type', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('base_expr', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('sub_tree', $object->parsed['WHERE'][$index]);
        switch ($index) {
          case '0':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], 'USR_ROLE');
            break;
          case '1':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'operator');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], '=');
            break;
          case '2':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], 'PROCESSMAKER_OPERATOR');
            break;
        }
        $index++;
      }
      
      $this->assertArrayHasKey('GROUP', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['GROUP']);
      $this->assertArrayHasKey('type', $object->parsed['GROUP'][0]);
      $this->assertArrayHasKey('base_expr', $object->parsed['GROUP'][0]);
      $this->assertArrayHasKey('direction', $object->parsed['GROUP'][0]);
      $this->assertEquals($object->parsed['GROUP'][0]['type'], 'expression');
      $this->assertEquals($object->parsed['GROUP'][0]['base_expr'], 'USR_STATUS');
      $this->assertEquals($object->parsed['GROUP'][0]['direction'], 'ASC');
      
      $this->assertArrayHasKey('HAVING', $object->parsed);
      $index = 0;
      while ($index < 3) {
        $this->assertArrayHasKey($index, $object->parsed['HAVING']);
        $this->assertArrayHasKey('expr_type', $object->parsed['HAVING'][$index]);
        $this->assertArrayHasKey('base_expr', $object->parsed['HAVING'][$index]);
        $this->assertArrayHasKey('sub_tree', $object->parsed['HAVING'][$index]);
        switch ($index) {
          case '0':
            $this->assertEquals($object->parsed['HAVING'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['HAVING'][$index]['base_expr'], 'USR_STATUS');
            break;
          case '1':
            $this->assertEquals($object->parsed['HAVING'][$index]['expr_type'], 'operator');
            $this->assertEquals($object->parsed['HAVING'][$index]['base_expr'], '=');
            break;
          case '2':
            $this->assertEquals($object->parsed['HAVING'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['HAVING'][$index]['base_expr'], 'ACTIVE');
            break;
        }
        $this->assertEquals($object->parsed['HAVING'][$index]['sub_tree'], '');
        $index++;
      }
      
      $this->assertArrayHasKey('ORDER', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['ORDER']);
      $this->assertArrayHasKey('type', $object->parsed['ORDER'][0]);
      $this->assertArrayHasKey('base_expr', $object->parsed['ORDER'][0]);
      $this->assertArrayHasKey('direction', $object->parsed['ORDER'][0]);
      $this->assertEquals($object->parsed['ORDER'][0]['type'], 'expression');
      $this->assertEquals($object->parsed['ORDER'][0]['base_expr'], 'USR_CREATE_DATE');
      $this->assertEquals($object->parsed['ORDER'][0]['direction'], 'DESC');

      //Testing with Select, avg, min, max, group_concat, distinct, order by, ASC, sum, grup by, having, count, >
      $sql = "SELECT student_name, AVG(test_score),MIN(test_score), MAX(test_score),GROUP_CONCAT(DISTINCT test_score ORDER BY test_score ASC SEPARATOR ' '), SUM(test_score) FROM student GROUP BY student_name HAVING COUNT(test_score) > 0 AND SUM(test_scoreid)";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      $this->assertArrayHasKey('SELECT', $object->parsed);
      $index = 0;
      while($index < 6) {
        $this->assertArrayHasKey($index, $object->parsed['SELECT']);
        $index++;
      }
      $array = array("expr_type" => 'colref', "alias" => '`student_name`', "base_expr" => 'student_name', "sub_tree" => '');
      $this->assertEquals($object->parsed['SELECT'][0], $array);
      
      $array = array("expr_type" => "expression", "alias" => "`AVG(test_score)`", "base_expr" => "AVG(test_score)", "sub_tree" => array ( "0" => array ( "expr_type" => "aggregate_function", "base_expr" => "AVG", "sub_tree" => ''), "1" => array ("expr_type" => "colref", "base_expr" => "(test_score)", "sub_tree" => '')));
      $this->assertEquals($object->parsed['SELECT'][1], $array);
      
      $array = array ("expr_type" => "expression","alias" => "`MIN(test_score)`","base_expr" => "MIN(test_score)","sub_tree" => array ( "0" => array ( "expr_type" => "aggregate_function","base_expr" => "MIN","sub_tree" => ''),"1" => array ("expr_type" => "colref", "base_expr" => "(test_score)", "sub_tree" => "")));
      $this->assertEquals($object->parsed['SELECT'][2], $array);
      
      $array = array ("expr_type" => "expression","alias" => "`MAX(test_score)`","base_expr" => "MAX(test_score)","sub_tree" => array ( "0" => array ( "expr_type" => "aggregate_function","base_expr" => "MAX","sub_tree" => ""), "1" => array ("expr_type" => "colref", "base_expr" => "(test_score)", "sub_tree" => "")));
      $this->assertEquals($object->parsed['SELECT'][3], $array);
      
      $array = array ( "expr_type" => "expression", "alias" => "`GROUP_CONCAT(DISTINCT test_score ORDER BY test_score ASC SEPARATOR ' ')`", "base_expr" => "GROUP_CONCAT(DISTINCT test_score ORDER BY test_score ASC SEPARATOR ' ')", "sub_tree" => array ("0" => array ( "expr_type" => "aggregate_function", "base_expr" => "GROUP_CONCAT", "sub_tree" => ""), "1" => array ( "expr_type" => "expression", "base_expr" => "(DISTINCT test_score ORDER BY test_score ASC SEPARATOR ' ')", "sub_tree" => array ( "0" => array ( "expr_type" => "reserved", "base_expr" => "DISTINCT", "sub_tree" => ""),"1" => array ( "expr_type" => "colref", "base_expr" => "test_score", "sub_tree" => ""),"2" => array ( "expr_type" => "reserved", "base_expr" => "ORDER", "sub_tree" => ""),"3" => array ( "expr_type" => "reserved", "base_expr" => "BY", "sub_tree" => ""), "4" => array ( "expr_type" => "colref", "base_expr" => "test_score", "sub_tree" => ""), "5" => array ( "expr_type" => "reserved", "base_expr" => "ASC", "sub_tree" => ""), "6" => array ( "expr_type" => "reserved", "base_expr" => "SEPARATOR", "sub_tree" => ""), "7" => array ( "expr_type" => "const", "base_expr" => "' '", "sub_tree" => "")))));
      $this->assertEquals($object->parsed['SELECT'][4], $array);
      
      $array = array ("expr_type" => "expression", "alias" => "`SUM(test_score)`", "base_expr" => "SUM(test_score)", "sub_tree" => array ("0" => array ( "expr_type" => "aggregate_function", "base_expr" => "SUM", "sub_tree" => ""), "1" => array ("expr_type" => "colref", "base_expr" => "(test_score)", "sub_tree" => "")));
      $this->assertEquals($object->parsed['SELECT'][5], $array);
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $array = array ('0' => array ("table" => "student","alias" => "student", "join_type" => "JOIN", "ref_type" => "", "ref_clause" => "", "base_expr" => "", "sub_tree" => ""));
      $this->assertEquals($object->parsed['FROM'], $array);
      
      $this->assertArrayHasKey('GROUP', $object->parsed);
      $array = array ("0" => array ( "type" => "expression", "base_expr" => "student_name", "direction" => "ASC"));
      $this->assertEquals($object->parsed['GROUP'], $array);
      
      $this->assertArrayHasKey('HAVING', $object->parsed);
      $array =  array ("0" => array ("expr_type" => "aggregate_function", "base_expr" => "COUNT", "sub_tree" => ""), "1" => array ("expr_type" => "colref", "base_expr" => "(test_score)", "sub_tree" => ""), "2" => array ("expr_type" => "operator", "base_expr" => ">", "sub_tree" => ""), "3" => array ( "expr_type" => "const", "base_expr" => "0", "sub_tree" => ""), "4" => array ( "expr_type" => "operator", "base_expr" => "AND", "sub_tree" => ""), "5" => array ("expr_type" => "aggregate_function", "base_expr" => "SUM", "sub_tree" => ""), "6" => array ("expr_type" => "colref", "base_expr" => "(test_scoreid)", "sub_tree" => ""));
      $this->assertEquals($object->parsed['HAVING'], $array);

      //Testing with Insert
      $sql = 'INSERT INTO USERS(USR_UID,USR_USERNAME,USR_PASSWORD,USR_FIRSTNAME,USR_LASTNAME,USR_EMAIL,USR_DUE_DATE,USR_CREATE_DATE,USR_UPDATE_DATE,USR_STATUS,USR_COUNTRY,USR_CITY,USR_LOCATION,USR_ADDRESS,USR_PHONE,USR_FAX,USR_CELLULAR,USR_ZIP_CODE,DEP_UID,USR_POSITION,USR_RESUME,USR_BIRTHDAY,USR_ROLE,USR_REPORTS_TO,USR_REPLACED_BY,USR_UX) VALUES (value1,value2,value3,value4,value5,value6,value7,value8,value9,value10,value11,value12,value13,value14,value15,value16,value17,value18,value19,value20,value21,value22,value23,value24,value25,value26)';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('INSERT', $object->parsed);
      $this->assertArrayHasKey('table', $object->parsed['INSERT']);
      $this->assertEquals($object->parsed['INSERT']['table'], 'USERS');
      
      $this->assertArrayHasKey('cols', $object->parsed['INSERT']);
      foreach ($value as $key => $val) {
        $this->assertArrayHasKey($key, $object->parsed['INSERT']['cols']);
        $this->assertEquals($object->parsed['INSERT']['cols'][$key], $value[$key]);
      }
      
      $this->assertArrayHasKey('VALUES', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['VALUES']);
      $this->assertTrue(is_string($object->parsed['VALUES'][0]));
      $this->assertCount(26, explode(',',$object->parsed['VALUES'][0]));

      //Testing with Insert, duplicate, update, key
      $sql = 'INSERT INTO USERS(USR_UID,USR_USERNAME,USR_PASSWORD,USR_FIRSTNAME,USR_LASTNAME,USR_EMAIL,USR_DUE_DATE,USR_CREATE_DATE,USR_UPDATE_DATE,USR_STATUS,USR_COUNTRY,USR_CITY,USR_LOCATION,USR_ADDRESS,USR_PHONE,USR_FAX,USR_CELLULAR,USR_ZIP_CODE,DEP_UID,USR_POSITION,USR_RESUME,USR_BIRTHDAY,USR_ROLE,USR_REPORTS_TO,USR_REPLACED_BY,USR_UX) VALUES (value1,value2,value3,value4,value5,value6,value7,value8,value9,value10,value11,value12,value13,value14,value15,value16,value17,value18,value19,value20,value21,value22,value23,value24,value25,value26) ON DUPLICATE KEY UPDATE value1=value1+1';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('INSERT', $object->parsed);
      $this->assertArrayHasKey('table', $object->parsed['INSERT']);
      $this->assertEquals($object->parsed['INSERT']['table'], 'USERS');
      
      $this->assertArrayHasKey('cols', $object->parsed['INSERT']);
      foreach ($value as $key => $val) {
        $this->assertArrayHasKey($key, $object->parsed['INSERT']['cols']);
        $this->assertEquals($object->parsed['INSERT']['cols'][$key], $value[$key]);
      }
      
      $this->assertArrayHasKey('VALUES', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['VALUES']);
      $this->assertTrue(is_string($object->parsed['VALUES'][0]));
      $this->assertCount(26, explode(',',$object->parsed['VALUES'][0]));
      
      $this->assertArrayHasKey('ON DUPLICATE KEY UPDATE', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['ON DUPLICATE KEY UPDATE']);
      $this->assertArrayHasKey('column', $object->parsed['ON DUPLICATE KEY UPDATE'][0]);
      $this->assertArrayHasKey('expr', $object->parsed['ON DUPLICATE KEY UPDATE'][0]);
      $this->assertEquals($object->parsed['ON DUPLICATE KEY UPDATE'][0]['column'], 'value1');
      $this->assertEquals($object->parsed['ON DUPLICATE KEY UPDATE'][0]['expr'], 'value1+1');

      //Testing with alter 
      $sql = "ALTER LOGFILE GROUP lg_3 ADD UNDOFILE 'undo_10.dat' INITIAL_SIZE=32M ENGINE=NDBCLUSTER;";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('ALTER', $object->parsed);
      $array = array ("0" => "ALTER");
      $this->assertEquals($object->parsed['ALTER'], $array);
      
      $this->assertArrayHasKey('GROUP', $object->parsed);
      $array = array ("0" => array("type" => "expression", "base_expr" => "lg_3 ADD UNDOFILE 'undo_10.dat' INITIAL_SIZE=32M ENGINE=NDBCLUSTER", "direction" => "ASC"));
      $this->assertEquals($object->parsed['GROUP'], $array);
      
      $this->assertArrayHasKey('SELECT', $object->parsed);
      $this->assertEquals($object->parsed['SELECT'], '');

      //Testing with create, view, !=, or, is, not, null, <> , '' 
      $sql = "CREATE VIEW test3 AS SELECT * FROM USERS WHERE USR_COUNTRY != 'US' AND USR_ADDRESS IS NOT NULL OR  USR_PHONE <> ''";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('CREATE', $object->parsed);
      $array = array ("CREATE");
      $this->assertEquals($object->parsed['CREATE'], $array);
      
      $this->assertArrayHasKey('VIEW', $object->parsed);
      $array = array ('test3','','AS','');
      $this->assertEquals($object->parsed['VIEW'], $array);
      
      $this->assertArrayHasKey('SELECT', $object->parsed);
      $array = array ("0" => array("expr_type" => "operator", "alias" => "`*`", "base_expr" => "*", "sub_tree" => ""));
      $this->assertEquals($object->parsed['SELECT'], $array);
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $array = array ("0" => array('table' => 'USERS', 'alias' => 'USERS', 'join_type' => 'JOIN', 'ref_type' => '', 'ref_clause' => '', 'base_expr' => '', 'sub_tree' =>''));
      $this->assertEquals($object->parsed['FROM'], $array);
      
      $this->assertArrayHasKey('WHERE', $object->parsed);
      $array = array ("0" => array ("expr_type" => "colref", "base_expr" => "USR_COUNTRY", "sub_tree" => ""), "1" => array ("expr_type" => "operator", "base_expr" => "!=", "sub_tree" => ""), "2" => array ("expr_type" => "const", "base_expr" => "'US'", "sub_tree" => ""), "3" => array ("expr_type" => "operator", "base_expr" => "AND", "sub_tree" => ""), "4" => array ("expr_type" => "colref", "base_expr" => "USR_ADDRESS", "sub_tree" => ""), "5" => array ("expr_type" => "operator", "base_expr" => "IS", "sub_tree" => ""), "6" => array ("expr_type" => "operator", "base_expr" => "NOT", "sub_tree" => ""), "7" => array ("expr_type" => "operator", "base_expr" => "NULL", "sub_tree" => ""), "8" => array ("expr_type" => "operator", "base_expr" => "OR", "sub_tree" => ""), "9" => array ("expr_type" => "colref", "base_expr" => "USR_PHONE", "sub_tree" => ""), "10" => array ("expr_type" => "operator", "base_expr" => "<>", "sub_tree" => ""), "11" => array ("expr_type" => "const", "base_expr" => "''", "sub_tree" => ""));
      $this->assertEquals($object->parsed['WHERE'], $array);

      //Testing with Truncate 
      $sql = "TRUNCATE USERS";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('TRUNCATE', $object->parsed);
      $array = array ("0" => "TRUNCATE", "1" => "USERS");
      $this->assertEquals($object->parsed['TRUNCATE'], $array);

      //Testing with show, like, key,%,' 
      $sql = "SHOW STATUS LIKE 'Key%';";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('SHOW', $object->parsed);
      $array = array ("0" => "SHOW", "1" => "STATUS", "2" => "", "3" => "LIKE", "4" => "", "5" => "'Key%'");
      $this->assertEquals($object->parsed['SHOW'], $array);

      //Testing with database 
      $sql = "CREATE DATABASE tmp";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('CREATE', $object->parsed);
      $array = array ('CREATE');
      $this->assertEquals($object->parsed['CREATE'], $array);
      
      $this->assertArrayHasKey('DATABASE', $object->parsed);
      $array = array ('tmp');
      $this->assertEquals($object->parsed['DATABASE'], $array);

      //Testing with drop, procedure, set, replace, concat, prepare, execute, using, dellocate, end
      $sql = "DROP PROCEDURE IF EXISTS TEST CREATE DEFINER = admin@localhost PROCEDURE TEST (IN param_USR_POSITION CHAR(15), IN param_USR_COUNTRY CHAR(5)) BEGIN SET @querry = 'select USR_UID, USR_USERNAME, REPLACE(USR_ROLE,'PROCESSMAKER_OPERATOR', 'OPERATOR') AS USR_ROLE from USERS'; SET @querry = CONCAT(@querry, ' where USR_POSITION=? and USR_COUNTRY=?'); SET @param_USR_POSITION = param_USR_POSITION; SET @param_USR_COUNTRY = param_USR_COUNTRY; PREPARE querry FROM @querry; EXECUTE querry USING @param_USR_POSITION, @param_USR_COUNTRY; DEALLOCATE PREPARE querry; END";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('PROCEDURE', $object->parsed);
      $array = array ('IF','','EXISTS','','TEST','','TEST','','(IN param_USR_POSITION CHAR(15), IN param_USR_COUNTRY CHAR(5))','','BEGIN','');
      $this->assertEquals($object->parsed['PROCEDURE'], $array);
      
      $this->assertArrayHasKey('CREATE', $object->parsed);
      $array = array ('CREATE');
      $this->assertEquals($object->parsed['CREATE'], $array);
      
      $this->assertArrayHasKey('DEFINER', $object->parsed);
      $array = array ('=','','admin@localhost','');
      $this->assertEquals($object->parsed['DEFINER'], $array);
      
      $this->assertArrayHasKey('SET', $object->parsed);
      $array = array ('0' => array("column" => "@querry", "expr" => "'select USR_UID, USR_USERNAME, REPLACE(USR_ROLE,'PROCESSMAKER_OPERATOR', 'OPERATOR') AS USR_ROLE from USERS'@querryCONCAT(@querry, ' where USR_POSITION=? and USR_COUNTRY=?')@param_USR_POSITIONparam_USR_POSITION@param_USR_COUNTRYparam_USR_COUNTRY"));
      $this->assertEquals($object->parsed['SET'], $array);
      
      $this->assertArrayHasKey('PREPARE', $object->parsed);
      $array = array ('querry','','','@querry','','querry','','END');
      $this->assertEquals($object->parsed['PREPARE'], $array);
      
      $this->assertArrayHasKey('EXECUTE', $object->parsed);
      $array = array ('querry','');
      $this->assertEquals($object->parsed['EXECUTE'], $array);
      
      $this->assertArrayHasKey('USING', $object->parsed);
      $array = array ("0" => array ("table" => "@param_USR_POSITION", "alias" => "@param_USR_POSITION", "join_type" => "JOIN", "ref_type" => "","ref_clause" => "","base_expr" => "","sub_tree" => ""), "1" => array ("table" => "@param_USR_COUNTRY", "alias" => "@param_USR_COUNTRY", "join_type" => "CROSS", "ref_type" => "","ref_clause" => "","base_expr" => "","sub_tree" => ""));
      $this->assertEquals($object->parsed['USING'], $array);

      //Testing with call 
      $sql = "CALL TESPROCEDURE (@VAR1)";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('CALL', $object->parsed);
      $array = array ('TESPROCEDURE', '','(@VAR1)');
      $this->assertEquals($object->parsed['CALL'], $array);

      //Testing with trigger, on,delayed, ingore, into 
      $sql = "CREATE TRIGGER testref BEFORE INSERT ON test1 FOR EACH ROW BEGIN INSERT DELAYED IGNORE INTO test2 SET a2 = NEW.a1; DELETE FROM test3 WHERE a3 = NEW.a1; UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1; END";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('CREATE', $object->parsed);
      $array = array ('CREATE');
      $this->assertEquals($object->parsed['CREATE'], $array);
      
      $this->assertArrayHasKey('TRIGGER', $object->parsed);
      $array = array ('testref','','BEFORE','');
      $this->assertEquals($object->parsed['TRIGGER'], $array);
      
      $this->assertArrayHasKey('INSERT', $object->parsed);
      $array = array ('table' => 'test2', 'cols' => 'ALL');
      $this->assertEquals($object->parsed['INSERT'], $array);
      
      $this->assertArrayHasKey('OPTIONS', $object->parsed);
      $array = array ('FOR UPDATE', 'DELAYED', 'IGNORE');
      $this->assertEquals($object->parsed['OPTIONS'], $array);
      
      $this->assertArrayHasKey('CREATE', $object->parsed);
      $array = array ('CREATE');
      $this->assertEquals($object->parsed['CREATE'], $array);
      
      $this->assertArrayHasKey('SET', $object->parsed);
      $array = array ('0' => array('column' => 'a2', 'expr' => 'NEW.a1b4b4+1'));
      $this->assertEquals($object->parsed['SET'], $array);
      
      $this->assertArrayHasKey('DELETE', $object->parsed);
      $array = array ('TABLES' => array('test3'));
      $this->assertEquals($object->parsed['DELETE'], $array);
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $array = array (array('table' => 'test3', 'alias' => 'test3', 'join_type' => 'JOIN', 'ref_type' => '', 'ref_clause' => '', 'base_expr' => '', 'sub_tree' =>''));
      $this->assertEquals($object->parsed['FROM'], $array);
      
      $this->assertArrayHasKey('WHERE', $object->parsed);
      $array = array (array ("expr_type" => "colref", "base_expr" => "a3", "sub_tree" => ""), array ("expr_type" => "operator", "base_expr" => "=", "sub_tree" => ""), array ("expr_type" => "colref", "base_expr" => "NEW.a1", "sub_tree" => ""), array ("expr_type" => "reserved", "base_expr" => "UPDATE", "sub_tree" => ""), array ("expr_type" => "colref", "base_expr" => "test4", "sub_tree" => ""), array ("expr_type" => "colref", "base_expr" => "a4", "sub_tree" => ""), array ("expr_type" => "operator", "base_expr" => "=", "sub_tree" => ""), array ("expr_type" => "colref", "base_expr" => "NEW.a1", "sub_tree" => ""), array ("expr_type" => "operator", "base_expr" => "END", "sub_tree" => ""));
      $this->assertEquals($object->parsed['WHERE'], $array);

      //Testing with alter, event, rename
      $sql = 'ALTER EVENT myevent RENAME TO yourevent';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('ALTER', $object->parsed);
      $array = array('ALTER');
      $this->assertEquals($object->parsed['ALTER'], $array);
      
      $this->assertArrayHasKey('EVENT', $object->parsed);
      $array = array('myevent','');
      $this->assertEquals($object->parsed['EVENT'], $array);
      
      $this->assertArrayHasKey('RENAME', $object->parsed);
      $array = array('','yourevent');
      $this->assertEquals($object->parsed['RENAME'], $array);

      //Testing with Create, Function, returns
      $sql = "CREATE FUNCTION TEST (chain CHAR(20)) RETURNS CHAR(50) RETURN CONCAT('Testing', ',chain,'!')";
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));
      
      $this->assertArrayHasKey('CREATE', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['CREATE']);
      $this->assertEquals($object->parsed['CREATE'][0], 'CREATE');
      
      $this->assertArrayHasKey('FUNCTION', $object->parsed);
      $index = 0;
      while($index < 4) {
        $this->assertArrayHasKey($index, $object->parsed['FUNCTION']);
        $index++;
      }
      
      $array = array('TEST','','(chain CHAR(20))','');
      $this->assertEquals($object->parsed['FUNCTION'], $array);
      
      $this->assertArrayHasKey('RETURNS', $object->parsed);
      $index = 0;
      while($index < 6) {
        $this->assertArrayHasKey($index, $object->parsed['RETURNS']);
        $index++;
      }
      
      $array = array('CHAR','(50)','','RETURN','','CONCAT',"('Testing', ',chain,'!')");
      $this->assertEquals($object->parsed['RETURNS'], $array);

      //Testing with Delete, where
      $sql = 'DELETE FROM USERS WHERE USR_UID = 00000000000000000000000000000001';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));

      $this->assertArrayHasKey('DELETE', $object->parsed);
      $this->assertArrayHasKey('TABLES', $object->parsed['DELETE']);
      $this->assertEquals($object->parsed['DELETE']['TABLES'][0], 'USERS');
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $this->assertEquals($object->parsed['FROM'][0]['alias'], 'USERS');
      
      $this->assertArrayHasKey('WHERE', $object->parsed);
      $index = 0;
      while ($index < 3) {
        $this->assertArrayHasKey($index, $object->parsed['WHERE']);
        $this->assertArrayHasKey('expr_type', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('base_expr', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('sub_tree', $object->parsed['WHERE'][$index]);
        switch ($index) {
          case '0':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], 'USR_UID');
            break;
          case '1':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'operator');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], '=');
            break;
          case '2':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'const');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], '00000000000000000000000000000001');
            break;
        }
        $index++;
      }

      //Testing with Delete, where, order by, limit
      $sql = 'DELETE FROM USERS WHERE USR_STATUS = ACTIVE ORDER BY USR_CREATE_DATE DESC LIMIT 4';
      $object->parse($sql);
      $this->assertTrue(is_array($object->parsed));

      $this->assertArrayHasKey('DELETE', $object->parsed);
      $this->assertArrayHasKey('TABLES', $object->parsed['DELETE']);
      $this->assertEquals($object->parsed['DELETE']['TABLES'][0], 'USERS');
      
      $this->assertArrayHasKey('FROM', $object->parsed);
      $this->assertEquals($object->parsed['FROM'][0]['alias'], 'USERS');
      
      $this->assertArrayHasKey('WHERE', $object->parsed);
      $index = 0;
      while ($index < 3) {
        $this->assertArrayHasKey($index, $object->parsed['WHERE']);
        $this->assertArrayHasKey('expr_type', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('base_expr', $object->parsed['WHERE'][$index]);
        $this->assertArrayHasKey('sub_tree', $object->parsed['WHERE'][$index]);
        switch ($index) {
          case '0':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], 'USR_STATUS');
            break;
          case '1':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'operator');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], '=');
            break;
          case '2':
            $this->assertEquals($object->parsed['WHERE'][$index]['expr_type'], 'colref');
            $this->assertEquals($object->parsed['WHERE'][$index]['base_expr'], 'ACTIVE');
            break;
        }
        $index++;
      }
      
      $this->assertArrayHasKey('ORDER', $object->parsed);
      $this->assertArrayHasKey('0', $object->parsed['ORDER']);
      $this->assertArrayHasKey('type', $object->parsed['ORDER'][0]);
      $this->assertArrayHasKey('base_expr', $object->parsed['ORDER'][0]);
      $this->assertArrayHasKey('direction', $object->parsed['ORDER'][0]);
      $this->assertEquals($object->parsed['ORDER'][0]['type'], 'expression');
      $this->assertEquals($object->parsed['ORDER'][0]['base_expr'], 'USR_CREATE_DATE');
      $this->assertEquals($object->parsed['ORDER'][0]['direction'], 'DESC');
      
      $this->assertArrayHasKey('LIMIT', $object->parsed);
      $this->assertArrayHasKey('start', $object->parsed['LIMIT']);
      $this->assertArrayHasKey('end', $object->parsed['LIMIT']);
      $this->assertEquals($object->parsed['LIMIT']['start'], '0');
      $this->assertEquals($object->parsed['LIMIT']['end'], '4');
    }

    /**
     * @covers PHPSQLParser::process_insert
     * @todo   Implement testProcess_insert().
     */
    //public function testProcess_insert()
    //{
    //    // Remove the following lines when you implement this test.
    //    //$this->markTestIncomplete(
    //    //  'This test has not been implemented yet.'
    //    //);
    //  $object = new PHPSQLParser();
    //  $table['INTO'] = array('users','name','lastname');
    //  $table = $object->process_insert($table);
    //  $this->assertArrayNotHasKey('INTO',$table);
    //  $this->assertTrue(is_array($table['INSERT']));
    //}

    /**
     * @covers PHPSQLParser::load_reserved_words
     * @todo   Implement testLoad_reserved_words().
     */
    public function testLoad_reserved_words()
    {
      $object = new PHPSQLParser();

      for ($i=0; $i<count($object->functions);$i++) {
        $this->assertEquals($object->functions[$i], strtoupper($object->functions[$i]));
      }
      for ($i=0; $i<count($object->reserved);$i++) {
        $this->assertEquals($object->reserved[$i], strtoupper($object->reserved[$i]));
      }
    }
}
